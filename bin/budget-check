#!/usr/bin/env python
# -*- coding: utf-8 -*-
from argparse import ArgumentParser
import os
from sr import budget, spending
import sys, yaml
from decimal import Decimal as D, ROUND_UP

parser = ArgumentParser( description = "Check the budget is valid" )
parser.add_argument( "-s", "--spending",
                     help = "The location of spending.git to check against" )
args = parser.parse_args()

try:
    root = budget.find_root()
except budget.NotBudgetRepo:
    print >>sys.stderr, "Error: Please run in budget.git"
    exit(1)

os.chdir( root )
b = budget.load_budget( "./" )

try:
    f = open( "funds-in.yaml", "r" )
except IOError:
    if os.path.exists( "check" ):
        os.execv( "./check", ["./check"] + sys.argv[1:] )
    exit(1)

funds_in = yaml.load( f )

total_in = D(0)

for i in funds_in["incoming"]:
    # Convert to str to avoid some rounding issues!
    total_in += D( str(i["amount"]) )

MAX = total_in

budgeted = D(0)

for line in b.walk():
    c = line.cost

    if line.closed:
        """Budget lines that are closed need no breathing space."""
        c /= budget.FUDGE_FACTOR
        # Round the result up for extra paranoia
        c = c.quantize(D("0.01"), rounding=ROUND_UP)

    budgeted += c

if budgeted > MAX:
    print >> sys.stderr, "Fail: Budget is £%s too high" % (budgeted - MAX)
    exit (1)

print "OK:",
if budgeted == MAX:
    print "Budget is at maximum."
else:
    print "Budget is £%s below maximum." % (MAX-budgeted)

if args.spending is not None:
    "Check stuff with spending.git"

    inv_budget_lines = {}
    grouped_trans = {}

    transactions = spending.load_transactions( args.spending )

    # Check that all transactions reference valid budget lines
    for trans in transactions:
        try:
            b.path( trans.budget )
        except budget.InvalidPath:

            if trans.budget not in inv_budget_lines:
                inv_budget_lines[trans.budget] = []

            inv_budget_lines[trans.budget].append( trans )
        else:
            if trans.budget not in grouped_trans:
                grouped_trans[trans.budget] = []
            grouped_trans[trans.budget].append( trans )

    if len(inv_budget_lines):
        print "{0} non-existent budget lines referenced from spending.git:".format( len(inv_budget_lines) )

        for line, tlist in inv_budget_lines.iteritems():
            print " - {0} is referenced in:".format( line )

            for t in tlist:
                print "\t", t.fname
    else:
        print "OK: All spending.git budget line references are valid."

    # Lines that have been closed but don't match their spends
    close_fail = {}

    # Lines that are over budget
    over_budget = {}

    # Check that the spends line up with the budget moneywise
    for bpath, tlist in grouped_trans.iteritems():
        spent = sum( [t.cost for t in tlist] )
        bline = b.path( bpath )

        if bline.closed:
            "Closed lines must match their spent amount"
            if bline.cost != spent:
                close_fail[bline] = spent

            continue

        fudged = bline.cost * budget.FUDGE_FACTOR
        if spent > fudged:
            over_budget[bline] = spent


    if len(close_fail):
        print "{0} closed lines do not match the amount spent against them:".format(
            len( close_fail ) )
        for line, spent in close_fail.iteritems():
            print " - {0}: £{1} spent, £{2} allocated".format(
                line.name,
                spent,
                line.cost )
    else:
        print "OK: All closed lines have the correct value."

    if len(over_budget):
        print "{0} lines are over budget:".format( len(over_budget) )
        for line, spent in over_budget.iteritems():

            print " - {0}: £{1} spent, £{2} allocated (including fudge)".format(
                line.name,
                spent,
                line.cost * budget.FUDGE_FACTOR )
    else:
        print "OK: No open budget lines are overspent."
